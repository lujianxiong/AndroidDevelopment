选择排序时间复杂度分析：
每一次遍历，假定未排序到合适位置的元素中第一个索引处是最小值(min=a[0])，和其他索引处的值依次比较
如果有索引处值小于当前索引，则假定这个索引的值为最小值，遍历完一次就可以找到第一个最小值，然后与当前索引处的值进行交换
简单地说：就是每次遍历都找出最小的元素放到合适的位置

最坏情况:
例子:假如对6,5,4,3,2,1进行排序

第一次遍历，假设第一个元素索引为i，minIndex=i；从minIndex处与i后面的每个元素j比较
外层for循环： int i=0;i<a[].length-1;i++     到倒数第二个结束（= i<=a[].length-2）
从索引0开始，内层for循环遍历完一次就i+1，第一次把最小的放到第一个索引位置，第二小的放第二个索引

外层for循环：int j=i+1;j<a[].length;j++    到最后一个索引处，即数组长度-1 （= j<=a[].length-1）
从索引i后面一个开始，minIndex与j一直比到最后一个做引处，每次比完得到一个最小值

元素比较的总次数为:(n-1)+(n-2)+(n-3)+...+2+1=(n^2-n)/2
元素交换总次数为 n-1

算法总执行次数为=元素比较总次数+元素总执行次数
                =(n^2-n)/2+(n-1）
                =n^2/2+n/2-1

根据大O推导法则，冒泡排序的时间复杂度为O(n^2)
O(n^2)这种时间复杂度的，一旦n增到很大，它的时间复杂度会急剧上升
选择排序也是适用于待排序元素较少的时候使用


